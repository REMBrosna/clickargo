{"ast":null,"code":"var path = require('path');\nvar Git = require('./git');\nvar async = require('async');\nvar fs = require('fs-extra');\n\n/**\n * Generate a list of unique directory paths given a list of file paths.\n * @param {Array.<string>} files List of file paths.\n * @return {Array.<string>} List of directory paths.\n */\nvar uniqueDirs = exports.uniqueDirs = function (files) {\n  var dirs = {};\n  files.forEach(function (filepath) {\n    var parts = path.dirname(filepath).split(path.sep);\n    var partial = parts[0] || '/';\n    dirs[partial] = true;\n    for (var i = 1, ii = parts.length; i < ii; ++i) {\n      partial = path.join(partial, parts[i]);\n      dirs[partial] = true;\n    }\n  });\n  return Object.keys(dirs);\n};\n\n/**\n * Sort function for paths.  Sorter paths come first.  Paths of equal length are\n * sorted alphanumerically in path segment order.\n * @param {string} a First path.\n * @param {string} b Second path.\n * @return {number} Comparison.\n */\nvar byShortPath = exports.byShortPath = function (a, b) {\n  var aParts = a.split(path.sep);\n  var bParts = b.split(path.sep);\n  var aLength = aParts.length;\n  var bLength = bParts.length;\n  var cmp = 0;\n  if (aLength < bLength) {\n    cmp = -1;\n  } else if (aLength > bLength) {\n    cmp = 1;\n  } else {\n    var aPart, bPart;\n    for (var i = 0; i < aLength; ++i) {\n      aPart = aParts[i];\n      bPart = bParts[i];\n      if (aPart < bPart) {\n        cmp = -1;\n        break;\n      } else if (aPart > bPart) {\n        cmp = 1;\n        break;\n      }\n    }\n  }\n  return cmp;\n};\n\n/**\n * Generate a list of directories to create given a list of file paths.\n * @param {Array.<string>} files List of file paths.\n * @return {Array.<string>} List of directory paths ordered by path length.\n */\nvar dirsToCreate = exports.dirsToCreate = function (files) {\n  return uniqueDirs(files).sort(byShortPath);\n};\n\n/**\n * Copy a file.\n * @param {Object} obj Object with src and dest properties.\n * @param {function(Error)} callback Callback\n */\nvar copyFile = exports.copyFile = function (obj, callback) {\n  var called = false;\n  function done(err) {\n    if (!called) {\n      called = true;\n      callback(err);\n    }\n  }\n  var read = fs.createReadStream(obj.src);\n  read.on('error', function (err) {\n    done(err);\n  });\n  var write = fs.createWriteStream(obj.dest);\n  write.on('error', function (err) {\n    done(err);\n  });\n  write.on('close', function () {\n    done();\n  });\n  read.pipe(write);\n};\n\n/**\n * Make directory, ignoring errors if directory already exists.\n * @param {string} path Directory path.\n * @param {function(Error)} callback Callback.\n */\nfunction makeDir(path, callback) {\n  fs.mkdir(path, function (err) {\n    if (err) {\n      // check if directory exists\n      fs.stat(path, function (err2, stat) {\n        if (err2 || !stat.isDirectory()) {\n          callback(err);\n        } else {\n          callback();\n        }\n      });\n    } else {\n      callback();\n    }\n  });\n}\n\n/**\n * Copy a list of files.\n * @param {Array.<string>} files Files to copy.\n * @param {string} base Base directory.\n * @param {string} dest Destination directory.\n * @return {Promise} A promise.\n */\nexports.copy = function (files, base, dest) {\n  return new Promise(function (resolve, reject) {\n    var pairs = [];\n    var destFiles = [];\n    files.forEach(function (file) {\n      var src = path.resolve(base, file);\n      var relative = path.relative(base, src);\n      var target = path.join(dest, relative);\n      pairs.push({\n        src: src,\n        dest: target\n      });\n      destFiles.push(target);\n    });\n    async.eachSeries(dirsToCreate(destFiles), makeDir, function (err) {\n      if (err) {\n        return reject(err);\n      }\n      async.each(pairs, copyFile, function (err) {\n        if (err) {\n          return reject(err);\n        } else {\n          return resolve();\n        }\n      });\n    });\n  });\n};\nexports.getUser = function (cwd) {\n  return Promise.all([new Git(cwd).exec('config', 'user.name'), new Git(cwd).exec('config', 'user.email')]).then(function (results) {\n    return {\n      name: results[0].output.trim(),\n      email: results[1].output.trim()\n    };\n  }).catch(function (err) {\n    // git config exits with 1 if name or email is not set\n    return null;\n  });\n};","map":{"version":3,"names":["path","require","Git","async","fs","uniqueDirs","exports","files","dirs","forEach","filepath","parts","dirname","split","sep","partial","i","ii","length","join","Object","keys","byShortPath","a","b","aParts","bParts","aLength","bLength","cmp","aPart","bPart","dirsToCreate","sort","copyFile","obj","callback","called","done","err","read","createReadStream","src","on","write","createWriteStream","dest","pipe","makeDir","mkdir","stat","err2","isDirectory","copy","base","Promise","resolve","reject","pairs","destFiles","file","relative","target","push","eachSeries","each","getUser","cwd","all","exec","then","results","name","output","trim","email","catch"],"sources":["D:/Collap Projects/ACLEDA-Student/student-ui/node_modules/gh-pages/lib/util.js"],"sourcesContent":["const path = require('path');\nconst Git = require('./git');\nconst async = require('async');\nconst fs = require('fs-extra');\n\n/**\n * Generate a list of unique directory paths given a list of file paths.\n * @param {Array.<string>} files List of file paths.\n * @return {Array.<string>} List of directory paths.\n */\nconst uniqueDirs = (exports.uniqueDirs = function(files) {\n  const dirs = {};\n  files.forEach(filepath => {\n    const parts = path.dirname(filepath).split(path.sep);\n    let partial = parts[0] || '/';\n    dirs[partial] = true;\n    for (let i = 1, ii = parts.length; i < ii; ++i) {\n      partial = path.join(partial, parts[i]);\n      dirs[partial] = true;\n    }\n  });\n  return Object.keys(dirs);\n});\n\n/**\n * Sort function for paths.  Sorter paths come first.  Paths of equal length are\n * sorted alphanumerically in path segment order.\n * @param {string} a First path.\n * @param {string} b Second path.\n * @return {number} Comparison.\n */\nconst byShortPath = (exports.byShortPath = (a, b) => {\n  const aParts = a.split(path.sep);\n  const bParts = b.split(path.sep);\n  const aLength = aParts.length;\n  const bLength = bParts.length;\n  let cmp = 0;\n  if (aLength < bLength) {\n    cmp = -1;\n  } else if (aLength > bLength) {\n    cmp = 1;\n  } else {\n    let aPart, bPart;\n    for (let i = 0; i < aLength; ++i) {\n      aPart = aParts[i];\n      bPart = bParts[i];\n      if (aPart < bPart) {\n        cmp = -1;\n        break;\n      } else if (aPart > bPart) {\n        cmp = 1;\n        break;\n      }\n    }\n  }\n  return cmp;\n});\n\n/**\n * Generate a list of directories to create given a list of file paths.\n * @param {Array.<string>} files List of file paths.\n * @return {Array.<string>} List of directory paths ordered by path length.\n */\nconst dirsToCreate = (exports.dirsToCreate = function(files) {\n  return uniqueDirs(files).sort(byShortPath);\n});\n\n/**\n * Copy a file.\n * @param {Object} obj Object with src and dest properties.\n * @param {function(Error)} callback Callback\n */\nconst copyFile = (exports.copyFile = function(obj, callback) {\n  let called = false;\n  function done(err) {\n    if (!called) {\n      called = true;\n      callback(err);\n    }\n  }\n\n  const read = fs.createReadStream(obj.src);\n  read.on('error', err => {\n    done(err);\n  });\n\n  const write = fs.createWriteStream(obj.dest);\n  write.on('error', err => {\n    done(err);\n  });\n  write.on('close', () => {\n    done();\n  });\n\n  read.pipe(write);\n});\n\n/**\n * Make directory, ignoring errors if directory already exists.\n * @param {string} path Directory path.\n * @param {function(Error)} callback Callback.\n */\nfunction makeDir(path, callback) {\n  fs.mkdir(path, err => {\n    if (err) {\n      // check if directory exists\n      fs.stat(path, (err2, stat) => {\n        if (err2 || !stat.isDirectory()) {\n          callback(err);\n        } else {\n          callback();\n        }\n      });\n    } else {\n      callback();\n    }\n  });\n}\n\n/**\n * Copy a list of files.\n * @param {Array.<string>} files Files to copy.\n * @param {string} base Base directory.\n * @param {string} dest Destination directory.\n * @return {Promise} A promise.\n */\nexports.copy = function(files, base, dest) {\n  return new Promise((resolve, reject) => {\n    const pairs = [];\n    const destFiles = [];\n    files.forEach(file => {\n      const src = path.resolve(base, file);\n      const relative = path.relative(base, src);\n      const target = path.join(dest, relative);\n      pairs.push({\n        src: src,\n        dest: target\n      });\n      destFiles.push(target);\n    });\n\n    async.eachSeries(dirsToCreate(destFiles), makeDir, err => {\n      if (err) {\n        return reject(err);\n      }\n      async.each(pairs, copyFile, err => {\n        if (err) {\n          return reject(err);\n        } else {\n          return resolve();\n        }\n      });\n    });\n  });\n};\n\nexports.getUser = function(cwd) {\n  return Promise.all([\n    new Git(cwd).exec('config', 'user.name'),\n    new Git(cwd).exec('config', 'user.email')\n  ])\n    .then(results => {\n      return {name: results[0].output.trim(), email: results[1].output.trim()};\n    })\n    .catch(err => {\n      // git config exits with 1 if name or email is not set\n      return null;\n    });\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}